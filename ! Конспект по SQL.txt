1. Что такое СУБД? Какие ты знаешь СУБД?
СУБД — это система управления базами данных. Так называют сложное программное обеспечение, которое требуется, чтобы создавать базы данных, изменять их, получать из них информацию и контролировать версии.
База данных — это хранилище, где находится информация. База может принадлежать сайту, приложению, любой программе: там будут находиться сведения, связанные с работой проекта. А СУБД — это программный комплекс, который позволяет администрировать базу, защищает ее целостность и конфиденциальность сведений.
По структуре и способу связей основные базы данных делятся на типы: иерархические, сетевые, колоночные, реляционные, нереляционные и объектно-ориентированные. Чтобы управлять данными в базе, используют СУБД (систему управления базами данных). Каждому типу баз подходят свои СУБД.
  

Системы управления бывают разными: различаются типы баз данных, особенности представления информации внутри базы, методы управления и языки, на которых пишутся запросы. Существуют платные и бесплатные СУБД, системы для локального или распределенного использования, предназначенные для крупных, средних или мелких проектов.
Есть разные типы управления базами данных. По способу хранения информации они делятся на:
Клиент-серверные. В этом случае СУБД находится на сервере, к которому пользователь отправляет запрос и этот же сервер его обрабатывает. Получить доступ к базе данных можно с любого компьютера. Это популярный вариант для интернет-магазинов
Файл-серверные. Такие СУБД размещают на локальных компьютерах, от которых исходит запрос. То есть пользователь должен иметь систему управления на своем компьютере, чтобы взаимодействовать с базой. Этот вариант подходит для корпоративного программного обеспечения
Встраиваемые. Такие системы управления поставляют как части программного продукта. Их не нужно устанавливать, это подключаемая библиотека
Для работы СУБД использует специальный язык запросов. По этому принципу они делятся на два вида:
Работающие на SQL — это главный язык структурированных запросов к базам данных. Его применяют к большинству БД
NoSQL — базы данных, к которым пишут запросы на одном из других языков программирования. Например, на Python. Его чаще применяют для работы с Big Data


2. Что такое БД? Какие бываю БД?
База данных — это место для хранения данных. Используется в том числе в клиент-серверной архитектуре. Это все интернет-магазины, сайты кинотеатров или авиабилетов... Вы делаете заказ, а система сохраняет ваши данные в базе.
  

Есть несколько основных видов баз данных.
* Реляционные
В них информацию хранят в виде таблиц, которые связаны друг с другом. Например, в интернет-магазине книг может быть сразу несколько таблиц. Одна отвечает за товарные позиции, в ней прописаны книги и их характеристики: стоимость, автор, количество страниц.
Есть вторая таблица. В ней записаны данные зарегистрированных пользователей: их имена, адреса, история покупок. Когда человек делает заказ, информация из одной таблицы отправляется во вторую.
Такая структура позволяет легко вносить изменения только в одну из них, а остальные будут по-прежнему ссылаться на нее.
* Нереляционные
Эти базы данных имеют отличную структуру, но являются менее распространенными. Они также существуют в нескольких вариациях. С пользовательской точки зрения их отличие заключается в невозможности писать запросы на языке SQL.
Обычно такие БД применяют для решения узкоспециализированных задач.
Ключ-значение
В таких базах данных информацию систематизируют через систему ключей. Обычно их применяют для хранения состояния объектов. Чтобы получить из нее элемент, необходимо ввести ключ. А все данные хранят в виде пар «ключ и значение».
Основная особенность таких баз — высокая скорость работы, но в отличие от реляционных они не поддерживают сложные запросы.
* Документоориентированные БД
Такие базы данных позволяют хранить документы. Каждый из них состоит из пары ключ-значение. Такая база неструктурированная, у нее нет схемы. В нее можно легко добавлять поля или удалять их, без затрагивания других частей таблицы.
Документы в таких базах также могут быть вложенными и храниться друг в друге. Их можно группировать и создавая коллекции с иерархией, что делает такие БД похожими на реляционные.
Для хранения данных в них используют форматы XML и JSON. Документоориентированные базы хороши тем, что позволяют по запросу получать сразу полный объект, а не его часть.
Их применяют на проектах, где нужно хранить много контента. Например, в мобильных приложения или играх.
* Графовые
Главная особенность таких баз данных — в существовании нескольких различных связей как между таблицами, так и между отдельными элементами. В их составе есть узлы, в которых находятся данные, и ребра — то есть соединения, описывающие их связи.
Графовые базы данных незаменимы для алгоритмов рекомендаций, которые используют социальные сети и другие сервисы.
Иерархические
В таких базах данных есть четкая иерархия, в основе которой лежит дерево из вышестоящих и подчиненных элементов. Они похожи на дерево папок в операционной системе.
По такой БД легко перемещаться вертикально. Но их используют только в ситуации, когда есть главные и подчиненные элементы, с четким разделением в данных.
* Колончатые
Структура таких баз данных тоже основана на таблицах. Но в отличие от реляционных, информация хранится в колонках без строгой структуры. Это позволяет содержать в них неструктурированные данные.
Обычно такие БД применяют для хранения логов или информации, полученной от умной техники.
NewSQL
Это самый молодой тип баз данных, основанный, с одной стороны, на распределенных системах NoSQL, но со структурой реляционных баз и языком запросов SQL.
NewSQL поддерживают масштабируемость и отвечают стандартам выполнения оперативных транзакций ACID.
Такие базы данных отличаются быстрой производительностью, горизонтальной масштабируемостью и транзакционностью.


3. В каком виде хранятся данные в Реляционных БД?
В них информацию хранят в виде таблиц, которые связаны друг с другом. Например, в интернет-магазине книг может быть сразу несколько таблиц. Одна отвечает за товарные позиции, в ней прописаны книги и их характеристики: стоимость, автор, количество страниц.
Есть вторая таблица. В ней записаны данные зарегистрированных пользователей: их имена, адреса, история покупок. Когда человек делает заказ, информация из одной таблицы отправляется во вторую.
Такая структура позволяет легко вносить изменения только в одну из них, а остальные будут по-прежнему ссылаться на нее.
В качестве примера реляционной базы данных рассмотрим таблицы, используемые небольшой фирмой для обработки заявок на продукцию. В первой табличной форме представлены сведения о заказчиках. Здесь в каждой записи представлена информация о названии и адресе клиента, его платежных реквизитах, контактном номере телефона и т.д.
Каждый атрибут данных (элемент информации) размещается в отдельном столбце информационной базы. Все столбцы имеют свой неповторяющийся идентификатор для каждой строки (ключ). Вторая табличная форма содержит отдельные записи с идентификатором клиента, подавшего заявку, наименование заказанного товара, его количество и характеристики. Как мы видим, в этой таблице отсутствуют данные клиента (название, телефон, адрес и т.д.).


4. Что такое SQL?
SQL или Structured Query Language (язык структурированных запросов) — язык программирования, предназначенный для управления данными в СУБД. Все современные СУБД поддерживают SQL. На языке SQL выражаются все действия, которые можно провести с данными: от записи и чтения данных, до администрирования самого сервера СУБД.


5. Какая разница между MySQL и SQL?
MySQL – это базовая технология, которая хранит данные, а SQL – это язык, который вы используете для чтения, изменения и удаления этих данных.
Для реляционных баз данных запросы пишутся на языке SQL. SQL — инструмент для СУБД. MySQL — реляционная СУБД, используемая SQL для обращения к подконтрольным ей базам данных. Соответственно, сравнение MySQL и SQL некорректно.


6. Что такое первичный ключ (Primary key)? Как использовать?
Первичный ключ (primary key) в SQL — это один или группа полей или столбцов, которые могут однозначно идентифицировать строку в таблице . Проще говоря, это столбец, который принимает уникальные значения для каждой строки, например, это может быть ID клиента или товара.
Первичный ключ — это поле или набор полей со значениями, которые являются уникальными для всей таблицы. Значения ключа могут использоваться для обозначения всех записей, при этом каждая запись имеет отдельное значение ключа. Каждая таблица может содержать только один первичный ключ.


7. Что такое внешний ключ (Foreign key)? Как использовать?
В реляционных базах данных внешние ключи (foreign key) используются для обеспечения целостности связей между таблицами. Простыми словами, внешний ключ — это столбец (или несколько столбцов), ссылающийся на первичный ключ другой таблицы. Таблица с внешним ключом называется дочерней, а с первичным — родительской.


8. Что такое реляции? Зачем нужны реляции?
Слово "реляция" происходит от "relation", то есть "отношение". Это означает, что в РБД существуют механизмы установления связей между таблицами. Делается это с помощью так называемых первичных и внешних ключей.


9. Приведи пример реляции, как она вообще работает?
Допустим, мы разрабатываем базу данных для сайта. Одна из таблиц будет содержать сведения о страницах сайта. Вторая таблица будет содержать описание разделов сайта. Каждая строка-запись первой таблицы должна в одном из своих полей содержать указание на раздел, к которому принадлежит описываемая этой записью страница.
Таким образом, мы разделяем разные сущности (страницы и разделы) по таблицам, но устанавливаем между ними связь. В последствии используя язык SQL мы сможем, например, создать запрос, который извлечет сведения о конкретном разделе и принадлежащих ему страницах. Хотя такой таблицы исходно нет.
Существуют определенные правила создания реляционных баз данных, их нормализации в основном с целью устранения избыточности. Теория разработки РБД – это целая наука.
Изучение реляционных баз данных включает теорию разработки РБД, язык SQL, СУБД
Хранение информации в базах данных дает преимущество не только с точки зрения обеспечения к ним быстрого доступа множества процессов. Базы данных, особенно реляционные, позволяют структурировать данные, манипулирования ими и легко наращивать объем.
Можно сказать, что в одной таблице содержатся ассоциированные данные, а в разных таблицах одной БД находятся связанные данные.


10. Какие ты знаешь JOIN? Распиши подробно про каждый.
JOIN — это SQL команда, используемая для работы с базами данных, которая объединяет данные из двух различных таблиц. Основная цель команды JOIN — получение необходимого подмножества данных.
Какие бывают с примерами подробно в ссылке:
* (INNER) JOIN - возвращает записи, имеющие соответствующие значения в обеих таблицах. Это наиболее часто используемый тип JOIN, так как он позволяет получить только те строки, которые имеют сопоставимые значения в обеих таблицах. Например, если у нас есть таблица employees и таблица departments, мы можем использовать INNER JOIN, чтобы получить список сотрудников, у которых есть назначенные отделы. Такой подход особенно полезен в тестировании, когда нужно проверить правильность данных в связанных таблицах.
— Вот небольшой пример использования:
select * from inventory
inner join sale
on sale.inventoryid=inventory.inventoryid
— Визуально выборка будет выглядеть следующим образом (закрашенная область):
* LEFT JOIN - возвращает все записи из левой таблицы и соответствующие записи из правой таблицы. Если соответствующих записей нет, результат будет содержать NULL значения для столбцов правой таблицы. Этот тип JOIN полезен для получения всех данных из основной таблицы (например, все сотрудники), даже если для некоторых записей нет соответствующих данных в связанной таблице (например, если у некоторых сотрудников нет назначенного отдела). Тестировщики часто используют LEFT JOIN, чтобы убедиться, что все данные из основной таблицы правильно обрабатываются и отображаются, даже если сопоставимых данных нет.
— Вот небольшой пример использования:
select inventory.inventoryid,inventoryname from inventory 
left join sale 
on sale.inventoryid=inventory.inventoryid
— Визуально выборка будет выглядеть следующим образом (закрашенная область):
* RIGHT JOIN - возвращает все записи из правой таблицы и сопоставленные записи из левой таблицы. Если соответствующих записей нет, результат будет содержать NULL значения для столбцов левой таблицы. Этот тип JOIN аналогичен LEFT JOIN, но с акцентом на правую таблицу. Он полезен, когда необходимо получить все данные из правой таблицы и соответствующие данные из левой таблицы. В тестировании RIGHT JOIN может быть использован для проверки полноты данных в зависимых таблицах.
— Вот небольшой пример использования:
select sale.inventoryid,inventoryname from inventory right join sale on sale.inventoryid=inventory.inventoryid
— Визуально выборка будет выглядеть следующим образом (закрашенная область):
* FULL JOIN - возвращает все записи, когда есть совпадение в левой или правой таблице. 
Если совпадений нет, результат будет содержать NULL значения для столбцов соответствующей таблицы. FULL JOIN объединяет LEFT JOIN и RIGHT JOIN, предоставляя полный набор данных из обеих таблиц. Это особенно полезно, когда нужно получить полное представление о данных из обеих таблиц, включая те, которые не имеют совпадений. Тестировщики могут использовать FULL JOIN для проверки данных на наличие разрывов и ошибок в обоих наборах данных.
— Вот небольшой пример использования:
select sale.inventoryid,inventoryname from inventory
full outer join sale on sale.inventoryid=inventory.inventoryid 
where sale.inventoryid is NULL
https://qalearning.net/usefullresourses/joins 


11. Что бы работали JOIN нужны ли реляции?
нет


12. Что такое Union? Как использовать?
Команда UNION объединяет данные из нескольких таблиц в одну при выборке. При объединении количество столбцов во всех таблицах должно совпадать, иначе будет ошибка. Имена столбцов будут такие же, как в основной таблице, в которую добавляются данные из других таблиц.
Внимание: если не используется ключевое слово ALL для UNION, все возвращенные строки будут уникальными, так как по умолчанию подразумевается DISTINCT, который удаляет неуникальные значения. Чтобы отменить такое поведение - нужно указать ключевое слово ALL, вот так: UNION ALL.
синтаксис и примеры:
Синтаксис
С удалением дублей:
SELECT * FROM имя_таблицы1 WHERE условие


        UNION SELECT * FROM имя_таблицы2 WHERE условие
Без удаления дублей:
SELECT * FROM имя_таблицы1 WHERE условие


        UNION ALL SELECT * FROM имя_таблицы2 WHERE условие
Можно объединять не две таблицы, а три или более:
SELECT * FROM имя_таблицы1 WHERE условие


        UNION SELECT * FROM имя_таблицы2 WHERE условие


        UNION SELECT * FROM имя_таблицы3 WHERE условие


        UNION SELECT * FROM имя_таблицы4 WHERE условие
13.  В чем разница между UNION и UNION ALL?
UNION ALL — повторяющиеся строки включаются. UNION — повторяющиеся строки исключаются.
UNION удаляет дубликаты записей (где все столбцы в результатах одинаковы), UNION ALL - объединяет без удаления дубликатов.
SELECT 'foo' AS bar UNION SELECT 'foo' AS bar
  

SELECT 'foo' AS bar UNION ALL SELECT 'foo' AS bar
  



14. Какие существуют типы связей в базе данных? Приведите примеры.
Связи делятся на:
* Многие ко многим.
* Один ко многим. с обязательной связью; с необязательной связью;
* Один к одному. с обязательной связью; с необязательной связью;
Связь «Один к одному»
Связь один к одному образуется, когда ключевой столбец (идентификатор) присутствует в другой таблице, в которой тоже является ключом либо свойствами столбца задана его уникальность (одно и тоже значение не может повторяться в разных строках).
На практике связь «один к одному» наблюдается не часто. Например, она может возникнуть, когда требуется разделить данных одной таблицы на несколько отдельных таблиц с целью безопасности.
В учебной базе данных нет подходящего примера, но гипотетически могла бы существовать необходимость разделения таблицы сотрудников.
Пример:
Представьте, что базой данных пользуются несколько менеджеров и аналитиков, а таблица «Сотрудники» содержит те же столбцы, что и учебная база. Следовательно, доступ к персональным данным может получить любой из упомянутых работников.
  

Наличие в таблице конфиденциальной информации
Чтобы устранить возможность утечки конфиденциальной информации, принимается решение о переносе информации паспортных данных в отдельную таблицу, доступ к которой предоставляется ограниченному кругу лиц.
Связь один к одному
  

Связь «Один ко многим»
В типе связей один ко многим одной записи первой таблицы соответствует несколько записей в другой таблице.
Рассмотрим связь учебной базы данных между должностями и сотрудниками, которая относится к рассматриваемому типу.
  

Связь один ко многим
Записи должностей в таблице «Должность» уникальны, так как нет смысла повторно создавать имеющуюся запись. Записи в таблице «Сотрудники» также уникальны, но несколько различных сотрудников могут находиться на одинаковой должностной позиции.
Символ ключа на конце связи указывает, что таблица, к которой этой конец прилегает, находится на стороне «один» (связанный столбец является первичным ключом), а символ бесконечности находится на стороне «многие» (такой столбец является внешним ключом).
Связь «Многие ко многим»
Если нескольким записям из одной таблицы соответствует несколько записей из другой таблицы, то такая связь называется «многие ко многим» и организовывается посредством связывающей таблицы.
В нашей базе подобное наблюдается только между таблицами с сотрудниками и линиями.
Связь многие ко многим
  

Из диаграммы видно, что имеются две связи «один ко многим» (один сотрудник может обрабатывать несколько телефонных линий, и одну линию могут обрабатывать несколько сотрудников), но в совокупности они образуют связь «многие ко многим».
Для чего все это нужно?
Связи выполняют более важную роль, чем просто информация размещения данных по таблицам. Прежде всего они требуются разработчикам для поддержания целостности баз данных.
Правильно настроив связи, можно быть уверенным, что ничего не потеряется.
Представьте, что Вы решили удалить одну из групп в таблице учебной базы данных. Если бы связи не было, то для тех сотрудников, которые к ней были определены, остался идентификатор несуществующей группы. Связь не позволит удалить группу, пока она имеется во внешних ключах других таблиц. Для начала следовало определить сотрудников в другие имеющиеся или новые группы, а только затем удалить ненужную запись. Поэтому связи называют еще ограничениями.


15. Что такое SELECT ? Как использовать?
Оператор SELECT в языке SQL используется для извлечения данных из одной или нескольких таблиц базы данных. Он позволяет выбирать определенные столбцы, фильтровать строки с помощью условий, сортировать результаты и объединять данные из разных таблиц.
Синтаксис:
SELECT column1, column2, ...
FROM table_name
WHERE condition;
Параметры:
1. column1, column2, ...: Список столбцов, которые вы хотите извлечь из таблицы.
2. table_name: Имя таблицы, из которой производится выборка.
3. condition: Условие, которое определяет, какие строки должны быть включены в результат. (Опционально)


16. Что такое подзапрос? Как использовать?
Подзапрос - это запрос в запросе. Выглядит как обычный запрос, которые мы рассматривали ранее, и так же возвращает набор строк. Подзапросы могут использоваться в любой части основного запроса. Его можно использовать для определения значения столбца в списке выборки SELECT.
Подзапрос — это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.
Как и любой другой SQL запрос, подзапрос возвращает результирующий набор, который может быть одним из следующих:
одна строка и один столбец;
нескольких строк с одним столбцом;
нескольких строк с несколькими столбцами.
В зависимости от типа результирующего набора подзапроса определяются операторы, которые могут использоваться в основном запросе.
Пример
Получим список всех бронирований самого дорогого на данный момент жилого помещения:
MySQL
SELECT * FROM Reservations
    WHERE Reservations.room_id = (
        SELECT id FROM Rooms ORDER BY price DESC LIMIT 1
    )
В данном случае запрос на получение самого дорогого жилого помещения выполняется в качестве подзапроса, а затем результат результирующего набора применяется в основном запросе.
MySQL
SELECT id FROM Rooms ORDER BY price DESC LIMIT 1


id
	21
	17. Что такое CREATE TABLE? Как использовать?
CREATE TABLE создаёт новую, изначально пустую таблицу в текущей базе данных.
SQL Синтаксис CREATE TABLE
CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    column3 datatype,
   ....
);
Параметры столбцов задают имена столбцов таблицы.
Параметр datatype указывает тип данных, которые может содержать столбец (например, varchar, integer, date и т.д.).
***
Типы данных столбцов
Для каждого столбца таблицы будет определен тип данных. Неправильное использование типов данных увеличивает как объем занимаемой памяти, так и время выполнения запросов к таблице. Это может быть незаметно на таблицах в несколько строк, но очень существенно, если количество строк будет измеряться десятками и сотнями тысяч, и это далеко не предел для рабочей базы данных. Проведем краткий обзор наиболее часто используемых типов.
Числовые типы
INT — целочисленные значения от −2147483648 до 2147483647, 4 байта.
DECIMAL — хранит числа с заданной точностью. Использует два параметра — максимальное количество цифр всего числа (precision) и количество цифр дробной части (scale). Рекомендуемый тип данных для работы с валютами и координатами. Можно использовать синонимы NUMERIC, DEC, FIXED.
TINYINT — целые числа от −127 до 128, занимает 1 байт хранимой памяти.
BOOL — 0 или 1. Однозначный ответ на однозначный вопрос — false или true. Название столбцов типа boolean часто начинается с is, has, can, allow. По факту это даже не отдельный тип данных, а псевдоним для типа TINYINT (1). Тип настолько востребован на практике, что для него в MySQL создали встроенные константы FALSE (0) или TRUE (1). Можно использовать синоним BOOLEAN.
FLOAT — дробные числа с плавающей запятой (точкой).
Символьные
VARCHAR(N) — N определяет максимально возможную длину строки. Создан для хранения текстовых данных переменной длины, поэтому память хранения зависит от длины строки. Наиболее часто используемый тип строковых данных.
CHAR(N) — как и с varchar, N указывает максимальную длину строки. Char создан хранить данные строго фиксированной длины, и каждая запись будет занимать ровно столько памяти, сколько требуется для хранения строки длиной N.
TEXT — подходит для хранения большого объема текста до 65 KB, например, целой статьи.
Дата и время
DATE — только дата. Диапазон от 1000-01-01 по 9999-12-31. Подходит для хранения дат рождения, исторических дат, начиная с 11 века. Память хранения — 3 байта.
TIME — только время — часы, минуты, секунды — «hh:mm:ss». Память хранения — 3 байта.
DATETIME — соединяет оба предыдущих типа — дату и время. Использует 8 байтов памяти.
TIMESTAMP — хранит дату и время начиная с 1970 года. Подходит для большинства бизнес-задач. Потребляет 4 байта памяти, что в два раза меньше, чем DATETIME, поскольку использует более скромный диапазон дат.
Бинарные
Используются для хранения файлов, фото, документов, аудио и видеоконтента. Все это хранится в бинарном виде.
LOB — до 65 КБ бинарных данных
LARGEBLOB — до 4 ГБ.
***
Атрибуты (ATTRIBUTES) и ограничения (CONSTRAINTS)
PRIMARY KEY
Предназначение индексов — обеспечить быстрый доступ к табличным данным. Основная идея — существенное ускорение поиска. Создание первичного ключа, внешних ключей, определение уникальных значений в столбце — во всех этих случаях будут созданы индексы. Существуют определенные ограничения на построения индексов в зависимости от типов данных, но разбор этих нюансов будет в других статьях.
Пользы индексов на примерах: для поиска уникального значения среди 10000 строк придется проверить, в худшем случае, все 10000 без индекса, с индексом — всего 14. Поиск по миллиону записей займет не больше в 20 проверок — это реализация идеи бинарного поиска.
Создадим таблицу Staff с номером сотрудника в качестве первичного ключа. Первичный ключ гарантирует нам, что номер точно будет уникальным, а поиск по нему — быстрым. 
CREATE TABLE Staff (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    position VARCHAR(30),
    birthday Date,
    has_children BOOLEAN
);
NOT NULL
При заполнении таблицы мы утверждаем, что значение этого столбца должно быть установлено. Если нет явного указания NOT NULL, и этот столбец не PRIMARY KEY, то столбец позволяет хранить NULL, то есть хранение NULL — поведение по умолчанию. Для первичного ключа это ограничение можно не указывать, так как первичный ключ всегда гарантирует NOT NULL.
Изменим команду CREATE TABLE, добавив NOT NULL ограничения: таким образом, мы обозначим обязательные для заполнения столбцы (т.е. столбцы, поля в которых не могут оставаться пустыми при наличии записи в таблице):    
CREATE TABLE Staff (
    id INT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    position VARCHAR(30),
    birthday DATE NOT NULL,
    has_children BOOLEAN NOT NULL
);
DEFAULT
Можно указать значение по умолчанию, т.е. текст или число, которые будут сохранены, если не указано другое значение. Применяется не ко всем типам: BLOB, TEXT, GEOMETRY и JSON не поддерживают это ограничение.
Эта величина должна быть константой, функция или выражение не допустимы.
Продолжим изменять команду, установив ограничение DEFAULT для поля BOOLEAN.   
CREATE TABLE Staff (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    position VARCHAR(30),
    birthday DATE NOT NULL,
    has_children BOOLEAN DEFAULT(FALSE) NOT NULL
);
Для типа данных BOOLEAN можно использовать встроенные константы FALSE и TRUE. Вместо DEFAULT(FALSE) можно указать DEFAULT(0) — эти записи эквивалентны.
AUTO_INCREMENT
Каждый раз, когда в таблицу будет добавлена запись, значение этого столбца автоматически увеличится. На всю таблицу этот атрибут применим только к одному столбцу, причем этот столбец должен быть ключом. Рекомендуется использовать для целочисленных значений. Нельзя сочетать с DEFAULT.
CREATE TABLE Staff (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    position VARCHAR(30),
    birthday DATE NOT NULL,
    has_children BOOLEAN DEFAULT(FALSE) NOT NULL
);
Теперь номер сотрудника будет автоматически последовательно увеличиваться при каждой новой записи в таблицу.
Интересно, что при CREATE TABLE MySQL не позволяет установить стартовое значение для AUTO_INCREMENT. Можно назначить стартовое значение для счетчика AUTO_INCREMENT уже созданной таблицы. 
Синтаксис:    
ALTER TABLE Staff AUTO_INCREMENT=10001;
Первая запись после такой модификации получит id = 10001.
UNIQUE
Это ограничение устанавливает, что все значения данного столбца будут уникальны в пределах таблицы, и создает индекс. Можно применять к столбцам с поддержкой NULL, но так как NULL будет считаться уникальным значением, возможна только одна NULL-запись.    
CREATE TABLE Staff (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    position VARCHAR(30),
    birthday DATE NOT NULL,
    has_child BOOLEAN DEFAULT(0) NOT NULL,
    phone VARCHAR(20) UNIQUE NOT NULL
);
CHECK
Позволяет установить дополнительную проверку данных для столбца или набора столбцов. Это тоже CONSTRAINT, так как накладывает ограничение.
На примере ограничим дату рождения сотрудника.
Синтаксис позволяет устанавливать CHECK как в описании столбца при CREATE TABLE:    
birthday DATE NOT NULL CHECK (birthday > ‘1900-01-01’),
так отдельно от описания столбцов:   
CHECK (birthday > ‘1900-01-01’),
В этих случаях название проверки будет определено автоматически. При вставке данных, не прошедших проверку, будет сообщение об ошибке Check constraint ‘staff_chk_1’ is violated. Ситуация усложняется, когда установлено несколько CHECK, поэтому рекомендуется давать понятное имя.
Воспользуемся полной командой для создания CHECK и определим не только ограничение даты рождения, но и допустимые форматы телефона через регулярное выражение.    
CREATE TABLE Staff (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    position VARCHAR(30),
    birthday DATE NOT NULL,
    has_child BOOLEAN DEFAULT(0) NOT NULL,
    phone VARCHAR(20) UNIQUE NOT NULL,
    CONSTRAINT staff_chk_birthday CHECK (birthday > '1900-01-01'),
    CONSTRAINT staff_chk_phone CHECK (phone REGEXP '[+]?[0-9]{1,3} ?\\(?[0-9]{3}\\)? ?[0-9]{2}[0-9 -]+[0-9]{2}')
);
Для добавления ограничений используем оператор CONSTRAINT, при этом, все названия уникальны, как и имена таблиц. Учитывая, что по умолчанию названия включают в себя и имя таблицы, рекомендуем придерживаться этого правила. Если используется CONSTRAINT, мы обязаны дать имя ограничению, которое вводим.
FOREIGN KEY или внешний ключ
Внешний ключ — это ссылка на столбец или группу столбцов другой таблицы. Это тоже ограничение (CONSTRAINT), так как мы сможем использовать только значения, для которых есть соответствие по внешнему ключу. Таблицу с внешним ключом называют зависимой.
Синтаксис:  
FOREIGN KEY (column_name1, column_name2) 
REFERENCES external_table_name(external_column_name1, external_column_name2)
Сначала указывается выражение FOREIGN KEY и набор столбцов таблицы, откуда строим FOREIGN KEY. Затем ключевое слово REFERENCES указывает на имя внешней таблицы и набор столбцов этой внешней таблицы. В конце можно добавить операторы ON DELETE и ON UPDATE, с помощью которых настраивается поведение при удалении или обновлении данных в главной таблице. Это делать не обязательно, так как предусмотрено поведение по умолчанию. Поведение по умолчанию запрещает удалять или изменять записи из внешней таблицы, если на эти записи есть ссылки по внешнему ключу.
Возможные опции для ON DELETE и ON UPDATE:
CASCADE: автоматическое удаление/изменение строк зависимой таблицы при удалении/изменении связанных строк главной таблицы.
SET NULL: при удалении/изменении связанных строк главной таблицы будет установлено значение NULL в строках зависимой таблицы. Столбец зависимой таблицы должен поддерживать установку NULL, т.е. параметр NOT NULL в этом случае устанавливать нельзя.
RESTRICT: не даёт удалить/изменить строку главной таблицы при наличии связанных строк в зависимой таблице. Если не указана иная опция, по умолчанию будет использовано NO ACTION, что, по сути, то же самое, что и RESTRICT.
Рассмотрим пример:
Для таблицы Staff было определено текстовое поле position для хранения должности.
Так как список сотрудников в компании обычно больше, чем список занимаемых должностей, есть смысл создать справочник должностей.    
CREATE TABLE Positions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL
);
Поскольку из Staff мы будем ссылаться на Positions, таблица персонала Staff будет зависимой от Positions. Изменим синтаксис CREATE TABLE для таблицы Staff, чтобы должность была ссылкой на запись в таблице Positions.    
CREATE TABLE Staff (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    position_id int,
    birthday DATE NOT NULL,
    has_child BOOLEAN DEFAULT(0) NOT NULL,
    phone VARCHAR(20) UNIQUE NOT NULL,
    FOREIGN KEY (position_id) REFERENCES Positions (id)
);
При CREATE TABLE, чтобы не усложнять описание столбца, рекомендуется указывать внешний ключ и все его атрибуты после перечисления создаваемых столбцов.
Можно ли добавить внешний ключ, если таблица уже создана и в ней есть данные? Можно! Для внесения изменений в таблицу используем ALTER TABLE
Синтаксис:   
ALTER TABLE Staff
ADD FOREIGN KEY (position_id) REFERENCES Positions(id);
Или в развернутой форме, определяя имя ключа fk_position_id явным образом: 
ALTER TABLE Staff
ADD CONSTRAINT fk_position_id FOREIGN KEY (position_id) REFERENCES Positions(id);
Главное условие в этом случае — согласованность данных. Это значит, что для всех записей внешнего ключа position_id должно найтись соответствие в целевой таблице Positions по столбцу id.
Создание таблиц на основе уже существующих, временные таблицы
Мы рассмотрели создание таблицы с «чистого листа», но есть два других способа:
LIKE
SELECT
LIKE
Создание таблицы на основе уже существующей таблицы. Копирует структуру — количество, названия и типы столбцов, индексы, все ограничения, кроме внешних ключей. Как мы помним, внешний ключ создает индекс. При создании через LIKE индексы в новой таблице будут построены также, как и в старой, но внешние ключи не скопируются. Таблица будет создана без записей и без счетчиков AUTO_INCREMENT.
Синтаксис:    
CREATE TABLE new_table LIKE source_table;
SELECT
Можно создать таблицу на основе SELECT-запроса — результат этой выборки будет записан в новую таблицу. Такая таблица не будет иметь индексов, ограничений и ключей. Все столбцы, с учетом порядка, типов данных и названий, будут взяты из запроса — поля из SELECT станут столбцами новой таблицы. При этом можно переопределить изначальные названия полей, что особенно актуально, когда в выборку попадают столбцы с одинаковыми названиями (на уровне таблицы названия столбцов всегда уникальны).
Синтаксис:   
CREATE TABLE new_table [AS] SELECT * FROM source_table;
Разберем пример создания новой таблицы через SELECT, используя две таблицы в выборке — Staff и Positions. В запросе определим три поля: id, staff, position — это будут столбцы новой таблицы StaffData211015 (срез сотрудников на определённую дату). Без присвоения псевдонимов (name as staff, name as position) в выборке получилось бы два одинаковых поля name, что не позволило бы создать таблицу из-за duplicate column name ошибки.   
CREATE TABLE StaffData211015
SELECT s.Id,
       s.name as staff,
       p.name as position
FROM Staff s
JOIN Positions p ON s.position_id = p.id
TEMPORARY
При подготовке отчетов или обработке данных на стороне базы, нередко может потребоваться сохранять промежуточные результаты в отдельные таблицы.
После завершения всех вычислений внутри скрипта эти вспомогательные таблицы нам будут уже не нужны. В таких ситуациях удобно использовать временные таблицы, которые будут существовать до завершения работы скрипта.
Чтобы обозначить таблицу как временную, нужно добавить TEMPORARY в CREATE TABLE:   
CREATE TEMPORARY TABLE table_name;
Работа с уже созданной таблицей
Когда таблица создана, работа с ней только начинается. Операторы и команды для работы с данными рассмотрены в другой статье, а сейчас посмотрим, что же можно исправить, если потребовалось внести изменения.
Переименование
Ключевая команда — RENAME.
Изменить имя таблицы:   
RENAME TABLE old_table_name TO new_table_name;
Изменить название столбца:   
ALTER TABLE table_name
RENAME COLUMN old_column_name TO new_column_name;
Удаление данных
DELETE FROM Staff; — удалит все записи из таблицы. Условие в WHERE позволит удалить только определенные строки, в примере ниже удалим только одну строку с id = 1. DELETE FROM Staff WHERE id = 1;
TRUNCATE TABLE Staff; — используется для полной очистки всей таблицы. При TRUNCATE счетчики AUTO_INCREMENT сбросятся. Если бы мы удалили все в строки командой DELETE, то новые строки учитывали бы накопленный за время жизни таблицы AUTO_INCREMENT.
DROP TABLE Staff; — команда удаления таблицы.
Изменение структуры таблицы
Команда ALTER TABLE включает в себя множество опций, рассмотрим основные вместе с примерами на таблице Staff.
Добавление столбцов
Добавим три столбца: электронную почту, возраст и наличие автомобиля. Так как в таблице уже есть записи, мы не можем пока что отметить эти поля как NOT NULL, по умолчанию они будут позволять хранить NULL.   
ALTER TABLE Staff
ADD email VARCHAR(50),
ADD age INT,
ADD has_auto BOOLEAN;
Удаление столбцов
Удалим столбец с возрастом, так как сейчас возраст сотрудников в базе всегда статичен, а должен быть вычисляемым полем в зависимости от текущей даты.  
ALTER TABLE Staff
DROP COLUMN age;
Значение по умолчанию
Выставим значение по умолчанию для столбца has_auto: 
ALTER TABLE Staff
ALTER COLUMN has_auto SET DEFAULT(FALSE);
Изменение типа данных столбца
Для столбца name изменим тип данных:
ALTER TABLE Staff
MODIFY COLUMN name VARCHAR(500) NOT NULL;
Максимальная длина поля была увеличена. Если не указать NOT NULL явно, то поле станет NULL по умолчанию.
Установка CHECK
Добавим ограничение формата для email через регулярное выражение:  
ALTER TABLE Staff
ADD CONSTRAINT staff_chk_email CHECK (email REGEXP '^[^@]+@[^@]+\\.[^@]{2,}$');
Заключение
Любой путь начинается с первых шагов. В работе с базами данных этими шагами является создание структуры таблиц. Продуманная композиция сущностей (таблиц) и связей между ними — основа проектирования любого вашего приложения от интернет-магазинов до мощных систем управления предприятиями.


18. Какие ты можешь использовать Числовые типы данных при создании таблицы?
Используются для хранения чисел и позволяют производить с ними арифметические операции, сравнения и другие математические расчеты. Числовые типы данных можно разделить на такие основные категории:
1. Целочисленные типы данных
Используются для хранения чисел без десятичных дробей. Они различаются по диапазону значений и объему занимаемой памяти.
TINYINT
Диапазон значений: от -128 до 127 для знаковых значений и от 0 до 255 для беззнаковых.
Размер: 1 байт.
Применение: Часто используется для хранения небольших чисел, таких как возраст.
СУБД: MySQL, SQL Server.
SMALLINT
Диапазон значений: от -32 768 до 32 767 для знаковых значений и от 0 до 65 535 для беззнаковых.
Размер: 2 байта.
Применение: Подходит для данных, которые требуют большего диапазона, чем TINYINT, но не настолько большого, чтобы использовать INT.
СУБД: PostgreSQL, MySQL, SQL Server.
MEDIUMINT
Диапазон значений: от -8 388 608 до 8 388 607 для знаковых значений и от 0 до 16 777 215 для беззнаковых.
Размер: 3 байта.
Применение: Используется в ситуациях, когда необходимо сбалансировать объем памяти и диапазон значений.
СУБД: MySQL.
INT (или INTEGER)
Диапазон значений: от -2 147 483 648 до 2 147 483 647 для знаковых значений и от 0 до 4 294 967 295 для беззнаковых.
Размер: 4 байта.
Применение: Один из самых часто используемых типов данных, подходящий для большинства целочисленных значений.
СУБД: PostgreSQL, MySQL, SQL Server, SQLite.
BIGINT
Диапазон значений: от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 для знаковых значений и от 0 до 18 446 744 073 709 551 615 для беззнаковых.
Размер: 8 байт.
Применение: Используется для хранения очень больших чисел, например, уникальных идентификаторов или подсчета объектов в крупных системах.
СУБД: PostgreSQL, MySQL, SQL Server.
2. Числа с фиксированной точностью и масштабом
Эти типы данных используются для хранения чисел с десятичными дробями, где важна точность, например, при работе с деньгами.
DECIMAL(p, s) или NUMERIC(p, s): Число с фиксированной точностью и масштабом, где p (precision) — это общее количество цифр, а s (scale) — количество цифр после десятичной точки. Например, DECIMAL(10, 2) может хранить числа с до 10 цифр, из которых 2 будут после десятичной точки.
Размер: Такой тип данных занимает переменное количество байт в зависимости от значения параметра p.
Применение: Часто используется в финансовых приложениях, где требуется высокая точность при расчетах (например, цены, балансы счетов).
СУБД: PostgreSQL, MySQL, SQL Server, SQLite.
3. Числа с плавающей точкой
Типы данных с плавающей точкой предназначены для хранения чисел, которые могут иметь широкий диапазон значений и требуют некоторого компромисса между точностью и объемом памяти.
FLOAT
Описание: FLOAT представляет числа с плавающей запятой, которые могут хранить значения с дробной частью. В зависимости от реализации СУБД, FLOAT может различаться по точности и диапазону значений. В некоторых СУБД FLOAT можно уточнить точность с помощью параметра p - FLOAT(p), где p указывает количество цифр в мантиссе. Например, FLOAT(7) может сохранять до 7 значащих цифр.
REAL: В некоторых СУБД FLOAT может быть синонимом REAL, который обычно имеет фиксированную точность и диапазон.
Размер: 4 или 8 байт в зависимости от СУБД.
Применение: Используется, когда требуется хранить числа с широкой степенью точности, например, результаты научных расчетов.
СУБД: PostgreSQL(Real), MySQL, SQL Server, SQLite (Real), Oracle.
DOUBLE PRECISION или просто DOUBLE
Описание: Число с плавающей точкой, аналогично FLOAT, но с удвоенной точностью.
Размер: 8 байт.
Применение: Подходит для хранения чисел, требующих большей точности, чем FLOAT, но с тем же компромиссом в плане точности при округлении.
СУБД: PostgreSQL, MySQL, Oracle.


19. Какие ты можешь использовать Текстовые типы данных при создании таблицы?
Тип данных TEXT в SQL используется для хранения значений строковых данных переменной длины . Он может хранить до 1 Гб данных. Он используется для хранения длинных предложений и значений данных, похожих на абзацы, таких как комментарии, ленты социальных сетей, текстовое содержимое веб-страницы в исходном коде страницы и т. д.
CHAR(n)
Описание: Тип данных CHAR(n) используется для хранения строк фиксированной длины. Здесь n — это количество символов, которое будет выделено для хранения строки.
Особенности: Если строка короче указанной длины, она автоматически дополняется пробелами до заданной длины. Например, если задан CHAR(5) и строка "SQL" имеет длину 3 символа, то она будет храниться как "SQL " (с двумя пробелами в конце).
Применение: CHAR используется для хранения данных, которые всегда имеют одинаковую длину, таких как коды стран, почтовые индексы или номера телефонов с фиксированной длиной.
СУБД: PostgreSQL, MySQL, SQL Server, Oracle.
VARCHAR(n)
Описание: Тип данных VARCHAR(n) используется для хранения строк переменной длины, где n — это максимальное количество символов, которое может быть сохранено.
Особенности: В отличие от CHAR, VARCHAR хранит только фактическое количество символов в строке и не дополняет её пробелами. Например, строка "SQL" в VARCHAR(5) будет занимать ровно 3 символа, без добавления пробелов.
Применение: VARCHAR широко используется для хранения данных, длина которых может варьироваться, таких как имена, электронные адреса, адреса и описания.
СУБД: PostgreSQL, MySQL, SQL Server, Oracle.
TEXT
Описание: TEXT используется для хранения длинных текстовых данных, таких как статьи, описания, комментарии или большие текстовые блоки.
Особенности: В отличие от CHAR и VARCHAR, тип TEXT может хранить строки большой длины (обычно до нескольких гигабайт). Однако он может иметь некоторые ограничения в зависимости от СУБД.
Применение: Применяется для хранения больших объемов текста, таких как описание продукта, статьи блога, комментарии пользователей и т.д.
СУБД: PostgreSQL, MySQL, SQL Server, SQLite.


20. Какие ты можешь использовать типы данных Даты при создании таблицы?
SQL Server поставляется со следующими типами данных для хранения даты или значения даты/времени в базе данных: DATE - формат ГГГГ-ММ-ДД . DATETIME - формат: ГГГГ-ММ-ДД ЧЧ:МИ:СС . SMALLDATETIME - формат: ГГГГ-ММ-ДД ЧЧ:МИ:СС .
краткая характеристика каждого из типов: 
TIMESTAMP — тип данных для хранения даты и времени. Данные хранятся в виде количества секунд, прошедших с начала «эпохи Юникса». Диапазон значений: 1970-01-01 00:00:00 — 2038-12-31 00:00:00. Занимает 4 байта.
YEAR — тип данных для хранения года. Диапазон значений: 1901 — 2155. Занимает 1 байт.
DATE — тип данных для хранения даты. Диапазон значений: 1000-01-01 — 9999-12-31. Занимает 3 байта.
TIME — тип данных для хранения времени. Диапазон значений: −828:59:59 — 828:59:59. Занимает 3 байта.
DATETIME — тип данных для хранения даты и времени. Диапазон значений: 1000-01-01 00:00:00 — 9999-12-31 00:00:00. Занимает 8 байт.
Для добавления даты в SQL можно использовать оператор INSERT . Пример добавления даты в таблицу будет выглядеть следующим образом: INSERT INTO table_name (date_column) VALUES ('2021-09-23'); Здесь table_name - название таблицы, date_column - название столбца, в который мы хотим добавить дату.
/
Мы также можем вставить дату, используя функцию 'to_date' в sql. Можно использовать следующий синтаксис: TO_DATE([value], [format]); Формат даты может быть разных типов, например: 'dd-mm-yyyy', 'yyyy-mm-dd', 'mm-dd-yyyy'


21. В чем разница между типом данных CHAR и VARCHAR в SQL?
Тип данных Char используется для хранения строк символов фиксированной длины. Тип данных Varchar используется для хранения строк символов переменной длины . Он использует статическую ячейку памяти. Он использует динамическую ячейку памяти.
Если необходимо обрабатывать многоязычные тексты или вы цените точность Unicode, то выбор в пользу NVARCHAR будет оптимальным. Однако если данные преимущественно англоязычные и важнее экономия ресурсов и производительность, то лучше выбрать VARCHAR.
CHAR(n) – n символов, от 1 до 32767, строковый тип фиксированной длины. Если содержимое поля меньше указанного размера, то оно "выравнивается" (добивается) дополнительными пробелами. VARCHAR(n) – n символов, от 1 до 32767, строковый тип переменной длины.
char и varchar — это строки однобайтовых символов, nchar и nvarchar содержат коды UTF-16 (первоначально UCS-2), 2 или 4 байта на символ . char и nchar — это фиксированные по длине, заполненные пустыми полями (оттенки COBOL). varchar(N) — это значения переменной длины, содержащие до N символов (N до 4000).


22. Чем NULL отличается от 0?
Если вы далеки от работы с базами данных, для вас может быть открытием, что ноль – это не значение NULL, хотя, признаем, они созвучны. Кроме того, NULL не является значением пустой строки, хотя можно найти поле, содержащее данные любого типа.
NULL означает, что значения нет, мы смотрим на пустую ячейку, а 0 означает, что само значение равно 0. Учитывая, что между NULL и 0 есть разница, способ, которым Tableau обрабатывает эти два значения, также отличается.


23. Какие ограничения существуют при создании таблиц?
Типы ограничений в SQL. Есть два вида ограничений: ограничения целостности данных и ограничения целостности ссылок. Ограничения ссылочной целостности обеспечивают целостность ссылок между связанными таблицами. К ним относится FOREIGN KEY constraint, или ограничение внешнего ключа.
Ограничение UNIQUE гарантирует, что значение столбца (или комбинация столбцов) в таблице будут уникальными. Это означает, что в столбце не может быть двух одинаковых значений. При попытке вставить или обновить значение, которое уже существует в столбце с ограничением UNIQUE , будет выдана ошибка.
Основы реляционных баз данных
Ограничения —
* Первичный ключ
* Внешний ключ
* Not Null
* Уникальность
Первичный ключ
Первичный ключ однозначно идентифицирует каждую запись внутри таблицы. Задается с помощью фразы PRIMARY KEY, которая добавляется после указания типа, когда создается таблица. Первичный ключ в таблице может быть только один, и для него используется суррогатный ключ — идентификатор, у которого нет физического смысла:
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text,
    price numeric
);
Внешний ключ
Внешний ключ — это ограничение, которое связывает указанную колонку с данными из другой таблицы. Такое ограничение гарантирует целостность данных. То есть попытка удалить данные, у которых есть зависимые данные, приведет к ошибке:
CREATE TABLE orders (
    id bigint PRIMARY KEY,
    product_id bigint REFERENCES products (id),
    quantity integer
);
В данной таблице атрибут product_id связан с атрибутом id таблицы products. Синтаксически для этого добавляется ключевое слово REFERENCES после типа поля. Затем добавляется имя таблицы, на которую идет связь. В скобках указывается поле, с которым эта связь создается. Наличие такой связи проявляется следующим образом:
Если попробовать вставить в orders запись со значением product_id, которого нет в таблице products, то возникнет ошибка
Если попытаться удалить запись из products, на которую есть ссылки из таблицы orders, то возникнет ошибка
Внешний ключ проверяет целостность данных и не позволяет появляться «мусору». Поэтому лучше ставить внешние ключи на все идентификаторы, для которых есть родительская таблица в базе.
Внешние ключи поддерживают несколько вариаций. Таким образом они поддерживают целостность, но не приводят к ошибкам при попытке удалить запись.
Вариант 1 — Каскадное удаление:
CREATE TABLE orders (
    product_id bigint REFERENCES products (id) ON DELETE CASCADE,
);
В таком варианте при попытке удалить родительскую запись (products) будут удалены все записи в orders, которые ссылаются на этот продукт. Каскадное удаление — опасная опция, так как можно случайно лишиться данных. Стоит хорошо подумать, прежде чем включать ее.
Вариант 2 — Записи остаются, но вместо идентификатора проставляется null:
CREATE TABLE orders (
    product_id bigint REFERENCES products (id) ON DELETE SET NULL
);
Используется нечасто, но иногда может быть полезно.
Not Null
Not Null — это ограничение указывает на то, что колонка не может содержать null значения. Его можно комбинировать с другими ограничениями, например, внешними ключами. Первичный ключ является NOT NULL по умолчанию:
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text NOT NULL,
    price numeric
);
CREATE TABLE orders (
    id bigint PRIMARY KEY,
    product_id bigint REFERENCES products (id) NOT NULL,
    quantity integer
);
Уникальность
Ограничение уникальности
Чтобы гарантировать уникальность значений одного поля, используется ключевое слово UNIQUE. Обычно его используют в описании конкретного поля, когда создается таблица:
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text UNIQUE,
    price numeric
);
UNIQUE никогда не используется совместно с первичным ключом, так как он уникален по определению.
Иногда бывает нужно реализовать уникальность по двум или более атрибутам. Для этого нужно описать UNIQUE отдельно от конкретного поля:
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text,
    locale varchar,
    price numeric,
    UNIQUE(name, locale)
);
Существует ситуация, в которой ограничение уникальности не срабатывает. Такое происходит, если хотя бы в одном из столбцов, включенных в ограничение, встречается NULL. По стандарту, NULL никогда не равен самому себе.


24. Что такое INSERT INTO? Как использовать?
INSERT INTO — команда для добавления данных в таблицу; table_name — название таблицы, в которую нужно добавить данные; column1, column2, column3, … — перечисление столбцов, в которые нужно добавить данные; value1, value2, value3, … — значения, которые нужно добавить в столбцы таблицы.
Оператор INSERT INTO используется для вставки новых записей в таблицу
INSERT — оператор языка SQL, который позволяет добавить строки в таблицу, заполняя их значениями. Значения можно вставлять перечислением с помощью слова values и перечислив их в круглых скобках через запятую или оператором select.


25. Что такое Update? Как использовать?
UPDATE — оператор языка SQL; команда, которая обновляет данные в таблице.
UPDATE — ее общий синтаксис такой: UPDATE [table] table_name SET column1 = value1, column2 = value2, ... [WHERE condition] [ORDER BY expression [ ASC | DESC ]] [LIMIT number_rows];
Синтаксис
UPDATE [top(x)] <объект> 
SET <присваивание1 [, присваивание2, ...]> 
[WHERE <условие>];
top(x) — команда выполнится только х раз
<объект> — объект, над которым выполняется действие (таблица или представление)
<присваивание> — присваивание, которое будет выполняться при каждом выполнении условия <условие>, или для каждой записи, если отсутствует раздел where
<условие> — условие выполнения команды
SET — после ключевого слова должен идти список полей таблицы, которые будут обновлены и непосредственно сами новые значения в виде
имя поля="значение"


26. Что такое DELETE, TRUNCATE и DROP? В чем их отличие?
В SQL (Structured Query Language) есть три часто используемых оператора для удаления данных или объектов из базы данных: DELETE, DROP и TRUNCATE.
Разница:
https://steringm.ru/blog/notes/2024/01/02/difference-between-delete-drop-and-truncate 


27. Что такое ALTER TABLE? Как использовать?
Оператор ALTER TABLE обеспечивает возможность изменять структуру существующей таблицы. Например, можно добавлять или удалять столбцы, создавать или уничтожать индексы или переименовывать столбцы либо саму таблицу. Можно также изменять комментарий для таблицы и ее тип.
Три действия, которые можно выполнить с помощью команды ALTER TABLE: 1- Заблокировать набор строк в таблице. 2- Удалить псевдостолбцы из таблицы. 3- Переименовать таблицу.
Синтаксис ALTER TABLE на примере MS SQL Server
Рассмотрим общий формальный синтаксис на примере SQL Server от Microsoft:
    ALTER TABLE имя_таблицы [WITH CHECK | WITH NOCHECK]
{ ADD имя_столбца тип_данных_столбца [атрибуты_столбца] | 
  DROP COLUMN имя_столбца |
  ALTER COLUMN имя_столбца тип_данных_столбца [NULL|NOT NULL] |
  ADD [CONSTRAINT] определение_ограничения |
  DROP [CONSTRAINT] имя_ограничения}
Итак, используя SQL-оператор ALTER TABLE, мы сможем выполнить разные сценарии 


28. Какие знаешь агрегатные функции? Как использовать?
Агрегатные функции SQL - это специализированные функции, которые выполняют вычисления над группами переменных и возвращают единый результат. В отличие от традиционных функций, агрегатные функции работают с группами строк данных. Это позволяет эффективно вычислять статистику или генерировать сводную информацию из набора данных.
В мире SQL агрегатные функции являются важными инструментами для эффективного обобщения и анализа данных. Они обладают уникальной способностью преобразовывать большие наборы данных в значимые аналитические данные, облегчать статистический анализ и упрощать сложные структуры данных.
Наиболее часто используются следующие агрегатные функции:
* SUM()
* COUNT()
* AVG()
* MIN()
* MAX()
1. SUM()
Функция SUM() возвращает итоговое значение числового столбца. Обычно она используется, когда вам нужно найти итоговое значение таких значений, как доход от продаж, количество или расходы.
Представьте, что вы хотите узнать весь доход вашей компании от продаж; вы можете сделать это, выполнив следующий запрос:
  

2. COUNT()
Следующая на очереди функция COUNT(). Целью этой функции является подсчет количества строк в таблице.
Предположим, вы хотите узнать, сколько товаров продается в вашем магазине; вы можете использовать следующий запрос:
В этом запросе мы используем звездочку (*) для обозначения всех столбцов. И мы подсчитываем все строки в запросе.
  

3. AVG()
Когда вам нужно вычислить среднее значение числового столбца, вы можете воспользоваться функцией AVG(). Это полезно при поиске средней цены, рейтинга, проданных единиц и так далее. Этот запрос, например, был бы полезен, если вы запускаете потоковую службу на основе подписки и хотите узнать среднюю продолжительность пользовательских сеансов на вашей платформе:
  

4. MIN()
Функция MIN() возвращает наименьшее значение в столбце. Она особенно полезна для поиска наименьшего значения в наборе данных.
Представьте себе менеджера, пытающегося определить максимально быстрое время ответа на вопрос клиента для обращения в службу поддержки; следующий запрос может вернуть ответ:
  

5. MAX()
С другой стороны, функция MAX() возвращает наибольшее значение в столбце. Она полезна для определения наибольшего значения в наборе данных.
Предположим, у вас есть сайт и вы хотите узнать максимальную стоимость заказа, сделанного клиентом в вашем интернет-магазине. Это запрос, который вы бы написали:
  



29. В чем разница между операторами GROUP BY и DISTINCT?
DISTINCT - получить уникальные строки (отличающиеся друг от друга любым отображаемым полем). Работает чуть быстрее. GROUP BY - сгруппировать по какому-либо признаку, при этом можно использовать агрегатные функции SUM, AVG, MAX и т.д.
Если главная цель — суммирование, то выбирайте GROUP BY. Если же нужно исключить дублирование, лучше всего подойдет DISTINCT.
Мы можем использовать ключевое слово DISTINCT и предложение GROUP BY, когда хотим получить уникальные записи таблицы в SQL.
DISTINCT служит для удаления дублирующихся значений из выбранных колонок:
SELECT DISTINCT column1 FROM table; -- Иногда одного примера более чем достаточно!
В то время как GROUP BY в сочетании с агрегирующими функциями объединяет строки с одинаковыми значениями в некоторых колонках и позволяет проводить операции над группами записей:
SELECT column1, COUNT(*) FROM table GROUP BY column1; -- Время для группировки и подсчёта!
Важное правило: применяйте DISTINCT для гарантии уникальности строк; используйте GROUP BY при работе с агрегацией данных с помощью функций таких как COUNT, SUM, AVG.


30. В чем разница между операторами WHERE и HAVING?
Основное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления агрегатов), тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных функций.
WHERE используется для фильтрации записей до группировки, отсеивая те, которые не удовлетворяют заданному критерию. В свою очередь, HAVING применяется после операции GROUP BY и позволяет отфильтровать группы записей по агрегированным значениям, получаемым с помощью функций SUM, AVG или COUNT.
Пример использования:
SELECT department, SUM(sales) AS total_sales
FROM orders
WHERE department <> 'Returns'  -- Исключаем негатив, связанный с возвратами.
GROUP BY department
HAVING SUM(sales) > 5000       -- В отчет включаем только значительные суммы.
Подробнее о WHERE и HAVING
Давайте ближе познакомимся с WHERE и HAVING. WHERE фильтрует данные прежде, чем происходит группировка, как бы выполняя предварительную проверку перед этапом агрегации.
HAVING, со своей стороны, действует как определенный контролер, проверяющий уже сгруппированные данные после применения GROUP BY. В отличие от WHERE, HAVING может применяться с агрегационными функциями.
Если GROUP BY не применяется, то HAVING может функционировать как WHERE. Однако это не самый эффективный способ использования HAVING, поскольку его предназначение — фильтрация данных после агрегации.
В процессе выполнения запроса WHERE действует раньше GROUP BY, а HAVING вступает в игру уже после этого. Учтя эту последовательность, можно настроить запросы наиболее оптимальным образом.
Распространенные ловушки и методы их устранения
При работе с SQL существуют ошибки, в которые легко вляпаться:
Применение HAVING без использования GROUP BY может привести к снижению производительности базы данных.
Попытка использования агрегатных функций с WHERE приведет к ошибке, т.к. WHERE функционирует до стадии агрегации.
Заблуждения о порядке выполнения условий могут сказаться на корректности результатов. Важно помнить, что WHERE идет до GROUP BY, а HAVING следует после.
Чтобы избежать этих проблем:
Используйте WHERE для уменьшения объема данных до их агрегации.
Применяйте HAVING для фильтрации результатов после группировки.
Всегда проверяйте логику запроса на небольшой выборке данных перед его выполнением на полном объеме данных.
Визуализация
Для более понятного представления разницы между HAVING и WHERE:
Проверка на входе (WHERE): 🚪👮
Ваш пропуск на "праздник" данных. WHERE фильтрует данные до начала этого мероприятия.
Пропуск в VIP-зону (HAVING): 🎟️🔒
Вы уже на "празднике", но получите ли доступ к VIP-зоне? HAVING – это фильтр для данных, которые уже "потусили" на "празднике" данных.
Таким образом, WHERE – это Чекпоинт 🚪, а HAVING – это Пропуск в VIP-зону 🎟️🔒.
Оптимизация SQL-запросов: улучшаем производительность
Правильное применение WHERE и HAVING может значительно улучшить производительность запросов. Вот несколько рекомендаций:
Индексация: Создание индексов для полей в условии WHERE может существенно ускорить выполнение запросов.
Сложные условия в HAVING: Если условия в HAVING слишком сложные, это может замедлить обработку запроса.
Временные таблицы: Возможность создания временных таблиц для выполнения сложных запросов стоит рассмотреть. Применяйте HAVING уже после агрегации данных в этих таблицах.
Коррелированные подзапросы: Where и Having
WHERE и HAVING можуть использоваться и в коррелированных подзапросах. WHERE не способен напрямую обрабатывать агрегированные данные, но коррелированный подзапрос может компенсировать этот недостаток. HAVING, приходя к выводам на основе агрегированных данных, не требует дополнительных обходных путей. Умение работать с этими клавими в контексте подзапросов отличает опытного специалиста SQL.
Предложение having используется для получения результатов путем добавления некоторых дополнительных условий. Предложение Group by является частью оператора Select и используется для извлечения значений из таблицы .
Предложение HAVING похоже на предложение WHERE, но применяется только к группам в целом (то есть к строкам в наборе результатов, представляющим группы), тогда как предложение WHERE применяется к отдельным строкам .
Часто встречается ошибка — оператор HAVING используется вместо WHERE в запросах с агрегацией. Это неверно! WHERE производит фильтрацию строк в исходном наборе данных, отсеивая неподходящие. После этого GROUP BY формирует группы и оператор HAVING производит фильтрацию уже целых групп (будто группа — одно запись).


31. Что такое Order by? Особенности работы Order by?
Для сортировки используется оператор ORDER BY . Он помогает сортировать данные в том порядке, который нам нужен. При этом, можно сортировать как по возрастанию 
через ASC , так и по убыванию с помощью DESC.
При выполнении SELECT запроса, строки по умолчанию возвращаются в неопределённом порядке. Фактический порядок строк в этом случае зависит от плана соединения и сканирования, а также от порядка расположения данных на диске, поэтому полагаться на него нельзя. Для упорядочивания записей используется конструкция ORDER BY.
Общая структура запроса с оператором ORDER BY:
SELECT поля_таблиц FROM наименование_таблицы
WHERE ...
ORDER BY столбец_1 [ASC | DESC][, столбец_n [ASC | DESC]]
Где ASC и DESC - направление сортировки:
ASC - сортировка по возрастанию (по умолчанию)
DESC - сортировка по убыванию
Например, выведем названия авиакомпаний в алфавитном порядке из таблицы Company:
MySQL
SELECT name FROM Company ORDER BY name;
name
Aeroflot
air_France
British_AW
Dale_avia
Don_avia
Разница между ORDER BY от GROUP BY:
ORDER BY это сортировка всего результата, а GROUP BY – применение к результату запроса группировки с агрегатными функциями MIN, MAX, AVG, COUNT и так далее.
При объединении предложений Group By и Order By важно помнить, что с точки зрения размещения в операторе SELECT: Предложение GROUP BY размещается после предложения WHERE. Предложение GROUP BY размещается перед предложением ORDER BY.


32. Для чего используются операторы IN, BETWEEN, LIKE?
Оператор BETWEEN
Оператор BETWEEN используется для выборки значений в указанном диапазоне. Он включает границы диапазона. Рассмотрим пример выборки студентов, родившихся между 1 января 1995 года и 31 декабря 2000 года:
SELECT * FROM Студенты
WHERE ДатаРождения BETWEEN '1995-01-01' AND '2000-12-31';
Результат выполнения
ID
	Имя
	Фамилия
	ДатаРождения
	Email
	1
	Иван
	Иванов
	1995-05-01
	ivanov@example.com
	2
	Мария
	Петрова
	1998-07-15
	petrova@example.com
	Оператор IN
Оператор IN используется для выборки значений, которые соответствуют любому из значений в указанном списке. Рассмотрим пример выборки студентов с фамилией «Иванов» или «Петрова»:
SELECT * FROM Студенты
WHERE Фамилия IN ('Иванов', 'Петрова');
Результат выполнения
ID
	Имя
	Фамилия
	ДатаРождения
	Email
	1
	Иван
	Иванов
	1995-05-01
	ivanov@example.com
	2
	Мария
	Петрова
	1998-07-15
	petrova@example.com
	Оператор LIKE
Оператор LIKE используется для выборки значений, которые соответствуют указанному шаблону. В шаблоне можно использовать символы подстановки:
* % — заменяет ноль или более символов
* _ — заменяет один символ
Рассмотрим пример выборки студентов, у которых email заканчивается на «@example.com»:
SELECT * FROM Студенты
WHERE Email LIKE '%@example.com';
Результат выполнения
ID
	Имя
	Фамилия
	ДатаРождения
	Email
	1
	Иван
	Иванов
	1995-05-01
	ivanov@example.com
	2
	Мария
	Петрова
	1998-07-15
	petrova@example.com
	



33. Какие условия выполнения операторов OR и AND?
При использовании оператора AND для выполнения условия должны быть выполнены оба подусловия которые он соединяет. Например условие A=5 AND D>10 будет выполнено только если значение A равняется 5 и значение D превышает 10 . При использовании оператора OR для выполнения условия достаточно выполнения одного из подусловий.
Операторы OR и AND имеют приоритет выполнения и у AND он выше.
Применение логических операторов
Логический оператор NOT перед условием обращает его, т.е. условие считается выполненным при его невыполнении. Например условие NOT A=5 считается выполненным в тех случаях когда А не равняется 5.
Несколько условий могут объединяться с помощью логических операторов соединения AND, OR <Условие1> <оператор соединения><Условие2>.
При использовании оператора AND для выполнения условия должны быть выполнены оба подусловия которые он соединяет. Например условие A=5 AND D>10 будет выполнено только если значение A равняется 5 и значение D превышает 10.
При использовании оператора OR для выполнения условия достаточно выполнения одного из подусловий.
Логические операторы могут соединять несколько условий, по цепочке, при этом сначала проверяются подусловия с оператором Not, затем подусловия соединенные операторами AND и затем, соединенные операторами OR. Для изменения порядка применения логических операторов можно заключать часть выражения в скобки, при этом операторы в скобках применяются в первую очередь.
Примеры применения логических операторов
Оператор NOT
SELECT * FROM Здания WHERE NOT Улица LIKE '%Южный пер.'
Выводятся все записи в которых значение поля Здания не оканчивается строкой Южный пер..
Оператор AND
SELECT * FROM Здания WHERE Улица='Нахимова' AND Area>500
Выводятся записи в которых значение поля Улица равняется строке Нахимова и значение поля Area превышает 500.
Оператор OR
SELECT * FROM Здания WHERE Perimeter>100 OR Area>500
Выводятся записи в которых значение поля Perimeter превышает 100, значение поля Area превышает 500, либо выполняются оба условия одновременно.
Одновременно несколько логических операторов
SELECT * FROM Здания WHERE Улица='1й Южный пер.' AND
[Номер дома] NOT BETWEEN 10 AND 20 OR
Улица='2й Южный пер.' AND [Номер дома] BETWEEN 1 AND 10
Выводятся все записи для домов по улице 1й Южный пер. кроме домов с 10 по 20 и все записи для домов улицы 2й Южный пер. с 1 по 10.
Изменение порядка применения операторов с помощью скобок
SELECT * FROM Здания WHERE
(Perimeter>100 OR Area>500) AND [Количество этажей] = 5
Выводятся все записи в который значение поля Количество этажей равно 5 и, одновременно значение поля Perimeter превышает 100, либо значение поля Area превышает 500.


34. Как работает оператор LIMIT?
Оператор SQL LIMIT выводит то количество записей, которое указано в параметре first_row. Если, через запятую указано значение параметра last_row, то будут выведены строки в диапазоне first_row — last_row включительно.
Оператор LIMIT позволяет извлечь определенное количество строк и имеет следующий синтаксис:
LIMIT [offset,] rowcount
Если оператору LIMIT передается один параметр, то он указывает на количество извлекаемых строк. Если передается два параметра, то первый параметр устанавливает смещение относительно начала, то есть сколько строк нужно пропустить, а второй параметр также указывает на количество извлекаемых строк.
Например, выберем первые три строки:
SELECT * FROM Products
LIMIT 3;
  

Оператор LIMIT в MySQL
Теперь используем второй параметр и укажем смещение, с которой должна происходить выборка:
SELECT * FROM Products
LIMIT 2, 3;
В данном случае пропускаются две первые строки и извлекаются следующие 3 строки:
  

LIMIT и OFFSET в MySQL
Как правило, оператор LIMIT используетс вместе с оператором ORDER BY:
SELECT * FROM Products
ORDER BY ProductName
LIMIT 2, 3;


35. Что такое нормализация и каковы ее преимущества?
Нормализация данных — это процесс организации данных в базе данных с целью уменьшения избыточности и улучшения целостности данных. Этот процесс включает в себя разделение больших таблиц на более мелкие и установление связей между ними. Нормализация помогает избежать аномалий при добавлении, обновлении и удалении данных. Важно понимать, что нормализация не только улучшает структуру базы данных, но и делает её более гибкой и масштабируемой. Это особенно важно в условиях растущих объемов данных и увеличивающихся требований к производительности.
Основные принципы нормализации
Нормализация данных основывается на нескольких ключевых принципах:
Избыточность данных: Уменьшение дублирования данных для экономии места и повышения эффективности. Избыточность данных может привести к увеличению объема хранимой информации и усложнению процессов её обработки.
Целостность данных: Обеспечение точности и согласованности данных в базе. Целостность данных гарантирует, что все данные в базе являются актуальными и непротиворечивыми.
Аномалии данных: Избежание проблем при изменении данных, таких как аномалии вставки, обновления и удаления. Аномалии могут привести к некорректным данным и нарушению целостности базы данных.
Преимущества нормализации данных
Нормализация данных имеет множество преимуществ:
Уменьшение избыточности: Снижение количества дублирующихся данных. Это позволяет экономить дисковое пространство и уменьшает затраты на хранение данных.
Повышение целостности данных: Обеспечение точности и согласованности данных. Это важно для принятия правильных решений на основе актуальной информации.
Улучшение производительности: Оптимизация запросов к базе данных. Нормализованные таблицы позволяют быстрее выполнять запросы и уменьшить время отклика системы.
Упрощение структуры базы данных: Легкость в понимании и управлении данными. Это облегчает работу разработчиков и администраторов баз данных, снижая вероятность ошибок.


36. Какие формы нормализации существуют?
Нормализация данных разделена на несколько форм, каждая из которых последовательно улучшает структуру данных в базе. Рассмотрим основные нормальные формы (NF) в SQL:
1. Первая нормальная форма (1NF)
Таблица находится в первой нормальной форме, если она удовлетворяет следующим условиям:
Все столбцы содержат только атомарные значения, то есть неделимые;
Все строки в таблице уникальны (дублирующие строки не допускаются);
Все столбцы содержат однотипные данные.
Пример:
Таблица, не находящаяся в 1NF:
  

Здесь у Ивана два телефона в одном поле, что нарушает принцип атомарности.
Нормализованная таблица (1NF):
  

Теперь каждый телефон записан в отдельной строке, и таблица удовлетворяет требованиям 1NF.
2. Вторая нормальная форма (2NF)
Таблица находится во второй нормальной форме, если она:
Находится в первой нормальной форме (1NF);
И все неключевые атрибуты полностью зависят от всего первичного ключа, а не от его части (для составных ключей).
Пример:
Таблица, не находящаяся в 2NF:
  

Предположим, что первичный ключ — это комбинация столбцов ID и Курс. Преподаватель зависит только от курса, а не от ID студента, следовательно, зависимость не полная, и эта таблица не удовлетворяет 2NF.
Нормализованная таблица (2NF):
Таблица курсов:
  

Таблица студентов:
  

Теперь каждый курс связан с преподавателем в отдельной таблице, и зависимость преподавателя от курса становится полной, что удовлетворяет требованиям 2NF.
3. Третья нормальная форма (3NF)
Таблица находится в третьей нормальной форме, если она:
Находится во второй нормальной форме (2NF);
И все неключевые атрибуты зависят только от первичного ключа и не зависят от других неключевых атрибутов (отсутствуют транзитивные зависимости).
Пример:
Таблица, не находящаяся в 3NF:
  

Здесь кабинет зависит от преподавателя, а не от ID или курса, что является нарушением 3NF.
Нормализованная таблица (3NF):
Таблица преподавателей и кабинетов:
  

Таблица студентов и курсов:
  

Таблица курсов и преподавателей:
  

Теперь зависимость кабинета от преподавателя устранена, и все неключевые атрибуты зависят только от первичного ключа.
Бойс-Коддова нормальная форма (BCNF)
BCNF — это более строгая версия третьей нормальной формы. Таблица находится в BCNF, если для каждого функционального зависимого отношения (X → Y), X является суперключом (ключом-кандидатом).
Пример:
Таблица, не находящаяся в BCNF:
  

Здесь у нас зависимость: курс определяет преподавателя, но курс не является ключом-кандидатом (ID студента тоже участвует в определении уникальности записи). Это нарушает BCNF.
Чтобы привести таблицу в BCNF, нужно разделить её на:
Таблицу курсов и преподавателей
Таблицу студентов и курсов.
Резюме
Нормализация помогает убрать избыточные и излишне сложные связи между таблицами в базе данных. Основные её этапы:
1NF: Устраняем повторяющиеся группы и делаем значения атомарными.
2NF: Полностью устраняем частичные зависимости от составных ключей.
3NF: Устраняем транзитивные зависимости (зависимости от неключевых атрибутов).
BCNF: Усложняем требования к функциональным зависимостям, чтобы каждая зависимость шла от суперключа.
Каждая последующая нормальная форма улучшает структуру данных, делая её более гибкой, управляемой и устойчивой к ошибкам при изменениях данных.
Утверждение выше (зачеркнутое) верно отчасти.
Исправляю:
Нормализация, особенно если стремиться к более высоким нормальным формам (например, BCNF и дальше), может привести к разбиению данных на слишком большое количество таблиц. Это, в свою очередь, может усложнить структуру базы данных и разработку приложения по нескольким причинам:
Сложные SQL-запросы: Чтобы получить данные, возможно, придется использовать сложные запросы с большим количеством JOIN операций, что может снизить читаемость кода и увеличить вероятность ошибок.
Падение производительности: Если количество таблиц и связей между ними становится слишком большим, это может негативно сказаться на производительности запросов, особенно если база данных не оптимизирована, индексы не настроены должным образом или объем данных большой.
Чрезмерная нормализация: В реальных проектах иногда приходится искать баланс между строгой нормализацией и удобством использования данных. Слишком жесткое следование нормализации может сделать систему трудной для сопровождения и использования.
Пример: Представьте, что у вас есть сильно нормализованная база данных, где для каждого атрибута, который может измениться, создана отдельная таблица. Это может привести к необходимости писать запросы, которые объединяют десятки таблиц через JOIN, что не только ухудшает производительность, но и усложняет понимание логики.
"Форм нормализации больше, чем четыре"
В учебных и практических материалах чаще всего упоминаются первые три формы и BCNF, поскольку они встречаются чаще и охватывают большинство сценариев.
Кроме 1NF, 2NF, 3NF и BCNF, существуют и другие нормальные формы, такие как:
Четвёртая нормальная форма (4NF): Устраняет многозначные зависимости. Она необходима, если существуют многозначные зависимости, которые могут привести к избыточности данных.
Пятая нормальная форма (5NF): Устраняет избыточность, если данные могут быть разложены на несколько таблиц, но при этом их нельзя восстановить без потери информации.
Шестая нормальная форма (6NF): Это скорее теоретическая форма, которая используется в специализированных областях (например, в хранилищах данных). Она направлена на устранение всех возможных избыточностей.
Доменно-ключевая нормальная форма (DKNF): Требует, чтобы все ограничения базы данных были выражены только через ключи и домены (типы данных). Это очень строгая форма, которая редко используется на практике.
Таким образом, количество нормальных форм действительно больше, чем те, которые обычно обсуждают, и это важно учитывать. В практической разработке редко когда требуется следовать нормализации дальше 3NF или BCNF, но знание о более высоких формах может быть полезным в сложных сценариях.
Баланс между нормализацией и денормализацией
Важно понимать, что нормализация и денормализация — это два крайних подхода к проектированию базы данных, и в большинстве реальных приложений приходится искать баланс между ними:
Нормализация помогает устранить избыточность и аномалии, обеспечивая согласованность данных.
Денормализация, с другой стороны, может улучшить производительность за счёт уменьшения количества JOIN и более простого доступа к данным.
Часто в реальных системах применяют частичную денормализацию, когда некоторые данные хранятся избыточно (например, для оптимизации чтения или уменьшения количества сложных запросов), но при этом дизайнеры базы данных стараются поддерживать баланс между нормализацией и производительностью.
При работе с базами данных:
Нормализация — это мощный инструмент, но его нужно применять с умом. Стремление к полной нормализации может привести к чрезмерной сложности базы данных и ухудшению производительности.
Высокие нормальные формы (4NF, 5NF и т.д.) существуют, но их необходимость зависит от специфики проекта.
В реальных проектах часто применяют гибкий подход: нормализуют данные до разумной степени, но при необходимости могут использовать денормализацию для улучшения производительности.
Важно помнить, что каждая задача требует индивидуального подхода. Иногда полная нормализация оправдана, иногда лучше оставить частичную денормализацию для повышения производительности или упрощения запросов.


37. Что такое денормализация?
Денормализация — это процесс объединения таблиц для уменьшения сложности запросов к базе данных . Это может привести к избыточности, но может привести к повышению производительности за счет сокращения количества требуемых соединений.
Обычно под этим термином понимают стратегию, применимую к уже нормализованной базе данных с целью повышения ее производительности. Смысл этого действия — поместить избыточные данные туда, где они смогут принести максимальную пользу. Для этого можно использовать дополнительные поля в уже существующих таблицах, добавлять новые таблицы или даже создавать новые экземпляры существующих таблиц. Логика в том, чтобы снизить время исполнения определенных запросов через упрощение доступа к данным или через создание таблиц с результатами отчетов, построенных на основании исходных данных.
Непременное условие процесса денормализации — наличие нормализованной базы. Важно понимать различие между ситуацией, когда база данных вообще не была нормализована, и нормализованной базой, прошедшей затем денормализацию. Во втором случае — все хорошо, а вот первый говорит об ошибках в проектировании или недостатке знаний у специалистов, которые этим занимались.
Когда полезно использовать денормализацию
Прежде чем браться разнормализовывать то, что уже однажды было нормализовано, естественно, нужно четко понимать, зачем это нужно? Следует убедиться, что выгода от применения метода перевешивает возможные негативные последствия. Вот несколько ситуаций, в которых определенно стоит задуматься о денормализации.
Сохранение исторических данных. Данные меняются с течением времени, но может быть нужно сохранять значения, которые были введены в момент создания записи. Например, могут измениться имя и фамилия клиента или другие данные о его месте жительства и роде занятий. Задача должна содержать значения полей, которые были актуальны на момент создания задачи. Если этого не обеспечить, то восстановить прошлые данные корректно не удастся. Решить проблему можно, добавив таблицу с историей изменений. В таком случае SELECT-запрос, который будет возвращать задачу и актуальное имя клиента будет более сложным. Возможно, дополнительная таблица — не лучший выход из положения.
Повышение производительности запросов. Некоторые запросы могут использовать множество таблиц для доступа к часто запрашиваемым данным. Пример — ситуация, когда необходимо объединить до 10 таблиц для получения имени клиента и наименования товаров, которые были ему проданы. Некоторые из них, в свою очередь, могут содержать большие объемы данных. При таком раскладе разумным будет добавить напрямую поле client_id в таблицу products_sold.
Ускорение создания отчетов. Бизнесу часто требуется выгружать определенную статистику. Создание отчетов по «живым» данным может требовать большого количества времени, да и производительность всей системы может в таком случае упасть. Например, требуется отслеживать клиентские продажи за определенный промежуток по заданной группе или по всем пользователям разом. Решающий эту задачу запрос в «боевой» базе перелопатит ее полностью, прежде чем подобный отчет будет сформирован. Нетрудно представить, насколько медленнее все будет работать, если такие отчеты будут нужны ежедневно.
Предварительные вычисления часто запрашиваемых значений. Всегда есть потребность держать наиболее часто запрашиваемые значения наготове для регулярных расчетов, а не создавать их заново, генерируя их каждый раз в реальном времени.
Вывод напрашивается сам собой: не следует обращаться к денормализации, если не стоит задач, связанных с производительностью приложения. Но если чувствуется, что система замедлилась или скоро замедлится, впору задуматься о применении данной техники. Однако, прежде чем обращаться к ней, стоит применить и другие возможности улучшения производительности: оптимизацию запросов и правильную индексацию.
Не все так гладко
Очевидная цель денормализации — повышение производительности. Но всему есть своя цена. В данном случае она складывается из следующих пунктов:
Место на диске. Ожидаемо, поскольку данные дублируются.
Аномалии данных. Необходимо понимать, что с определенного момента данные могут быть изменены в нескольких местах одновременно. Соответственно, нужно корректно менять и их копии. Это же относится к отчетам и предварительно вычисляемым значениям. Решить проблему можно с помощью триггеров, транзакций и хранимых процедур для совмещения операций.
Документация. Каждое применение денормализации следует подробно документировать. Если в будущем структура базы поменяется, то в ходе этого процесса нужно будет учесть все прошлые изменения — возможно, от них вообще можно будет к тому моменту отказаться за ненадобностью. (Пример: в клиентскую таблицу добавлен новый атрибут, что приводит к необходимости сохранения прошлых значений. Чтобы решить эту задачу, придется поменять настройки денормализации).
Замедление других операций. Вполне возможно, что применение денормализации замедлит процессы вставки, модификации и удаления данных. Если подобные действия проводятся относительно редко, то это может быть оправдано. В этом случае мы разбиваем один медленный SELECT-запрос на серию более мелких запросов по вводу, обновлению и удалению данных. Если сложный запрос может серьезно замедлить всю систему, то замедление множества небольших операций не отразится на качестве работы приложения столь драматических образом.
Больше кода. Пункты 2 и 3 потребуют добавления кода. В то же время они могут существенно упростить некоторые запросы. Если денормализации подвергается существующая база данных, то потребуется модифицировать эти запросы, чтобы оптимизировать работу всей системы. Также понадобится обновить существующие записи, заполнив значения добавленных атрибутов — это тоже потребует написания некоторого количества кода.


38. Из каких подмножеств состоит SQL?
SQL (Structured Query Language) — мощный инструмент для взаимодействия с реляционными базами данных. Он позволяет пользователям управлять данными, определять структуры, запрашивать информацию и поддерживать целостность транзакций. В SQL есть четыре ключевых подмножества запросов: DML, DQL, DDL и TCL. В этой записи блога мы углубимся в каждое подмножество, понимая их роли, синтаксис и значение в сфере управления базами данных.
DML — язык манипулирования данными:
Определение и назначение: DML занимается изменением и манипулированием данными, хранящимися в базе данных. Он включает команды, которые позволяют вставлять, обновлять и удалять записи в таблицах. DML является краеугольным камнем поддержания и обновления данных.
Общие команды DML:
INSERT: Добавляет новые записи в таблицу.
UPDATE: Изменяет существующие записи в таблице.
DELETE: Удаляет записи из таблицы.
Пример:
ВСТАВИТЬ  В Клиенты (Имя, Электронная почта) ЗНАЧЕНИЯ ( 'John Doe' , 'john@example.com' ); 
ОБНОВИТЬ Продукты УСТАНОВИТЬ Цена =  29.99  ГДЕ Категория =  'Электроника' ; 
УДАЛИТЬ  ИЗ Заказы ГДЕ OrderDate <  '2023-01-01' ;
DQL — язык запросов данных:
Определение и цель: DQL ориентирован на запросы и извлечение данных из базы данных. Основной командой в DQL является SELECTоператор, который позволяет извлекать определенные столбцы и строки на основе указанных критериев.
Общие команды DQL:
SELECT: Извлекает данные из одной или нескольких таблиц на основе указанных условий.
Пример:
ВЫБЕРИТЕ Имя, Фамилия ИЗ Сотрудники , ГДЕ Отдел =  'HR' ; 
ВЫБЕРИТЕ НазваниеПродукта, Цена ИЗ Продукты , ГДЕ Цена <  50 ;
DDL — язык определения данных:
Определение и назначение: DDL используется для определения и управления структурой базы данных. Он включает команды для создания, изменения и удаления объектов базы данных, таких как таблицы, индексы и представления.
Распространенные команды DDL:
CREATE: Создает новые объекты базы данных, такие как таблицы, индексы или представления.
ALTER: Изменяет существующие объекты базы данных, например, добавляет или удаляет столбцы из таблицы.
DROP: Удаляет объекты базы данных, такие как таблицы или индексы.
Пример:
CREATE  TABLE Студенты (ID INT  PRIMARY KEY, Name VARCHAR ( 50 )); 
ALTER  TABLE Клиенты ADD  COLUMN Возраст INT ; 
DROP  TABLE Заказы;
TCL — язык управления транзакциями:
Определение и назначение: TCL отвечает за управление транзакциями в базе данных. Он обеспечивает целостность данных, контролируя начало, завершение и откат транзакций.
Общие команды TCL:
COMMIT: Сохраняет все изменения, внесенные во время текущей транзакции.
ROLLBACK: Отменяет изменения, внесенные во время текущей транзакции.
SAVEPOINT: Устанавливает точку внутри транзакции, к которой можно впоследствии вернуться.
SET TRANSACTION: Указывает характеристики транзакции, такие как уровень изоляции.
Пример:
НАЧАТЬ ТРАНЗАКЦИЮ; 
ОБНОВИТЬ инвентарь УСТАНОВИТЬ Количество = Количество -  10  ГДЕ ProductID =  101 ; 
ТОЧКА СОХРАНЕНИЯ sp1; 
ОБНОВИТЬ заказы УСТАНОВИТЬ Статус =  «Отправлено»  ГДЕ OrderID =  201 ; 
ОТКАТ  К sp1; 
ЗАФИКСИРОВАТЬ ;